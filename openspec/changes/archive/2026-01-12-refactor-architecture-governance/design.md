## Context

项目已具备较明确的模块化分层与依赖治理文档，并提供了 `./gradlew verifyModuleDependencies` 作为自动化校验。此变更聚焦把“架构一致性与性能治理”从文档/口头约定，提升为可持续的规范与门禁，并把当前已识别的改造点纳入可执行的任务序列。

本变更属于跨模块、跨层（UI / 基础设施 / 播放链路）的治理型改造，因此需要在编码前明确目标、边界与风险控制策略。

## Goals / Non-Goals

### Goals（目标）

- 用 OpenSpec 固化可执行的架构治理要求（依赖、边界、线程/性能基线）。
- 统一关键 UI 模式（分页/多页设置等），减少旧组件/旧 API 继续扩散。
- 针对播放代理链路的阻塞点做“可解释、可回归”的治理，降低性能与稳定性风险。

### Non-Goals（非目标）

- 不在本变更内做“全量重构/大迁移”（例如：引入完整 DI 框架、重命名所有包结构、跨模块大规模搬家）。
- 不以“最小侵入”为第一原则；但会坚持“可回归、可分阶段落地”的迁移策略，避免一次性推倒重来。

## Decisions

1. **用 OpenSpec 建立 `architecture-governance` 能力规格**
   - 将模块依赖治理、UI 一致性、线程/性能守则表达为可验证的 Requirement + Scenario。
2. **UI Pager 统一迁移到 ViewPager2**
   - 现存 `FragmentPagerAdapter/ViewPager` 作为技术债清单逐步迁移，并增加静态门禁避免新增。
3. **播放代理链路的阻塞治理以“线程模型明确化 + 非主线程保证”为优先**
   - 对 `runBlocking` 等桥接点，先明确调用线程与并发模型，再选择替换方案（同步网络调用 / IO dispatcher / 协程化 server 等）。
4. **Debug 阶段前置性能退化暴露**
   - 通过 StrictMode 等机制，让主线程阻塞、磁盘/网络误用在开发阶段可见；Release 不引入额外运行时开销。

## Alternatives Considered

- **仅更新文档，不加门禁/不做迁移**：短期最省事，但无法阻止架构退化，长期维护成本更高。
- **一次性全量迁移 UI 与播放链路**：落地风险过高，回归成本大，容易引入难定位的回归。
- **引入大型 DI/架构框架以“强制约束”**：收益存在，但引入成本与迁移跨度大；当前优先用“契约层 + 依赖治理 + 小步迁移”达成一致性目标。

## Risks / Trade-offs

- **UI 回归风险**：ViewPager2 行为与旧 ViewPager 存在差异（生命周期、缓存策略、焦点/TV 导航等）。
  - 缓解：按页面逐个迁移；补齐关键交互回归清单；必要时保留兼容层/开关。
- **播放链路回归风险**：本地代理/Range 请求等属于核心链路，任何改动都可能影响可播性与稳定性。
  - 缓解：先做“线程模型与行为一致性”的最小变更；增加自动化/手工回归验证；优先保证“可回退”。

## Migration Plan

按 `tasks.md` 的顺序逐步落地：先建立规格与门禁，再做 UI Pager 迁移，最后治理播放代理阻塞点，并用 Gradle 校验与（必要的）仪表测试兜底。

## Open Questions

- UI Pager 迁移是否需要一次性覆盖所有入口，还是可以按高频页面优先？
- 播放代理链路的治理优先级：先做 `runBlocking` 替换，还是先补测试与指标再改？
- Debug StrictMode 策略：只记录日志还是在严重场景下主动 crash（更早暴露问题但影响调试体验）？

