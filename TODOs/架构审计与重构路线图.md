# 架构审计与重构路线图（DanDanPlayForAndroid）

> 目的：从软件工程角度审视当前模块化与代码结构，识别高耦合与设计风险，并给出可执行、可分阶段落地的重构路线图（强调“架构与逻辑一致性”优先于“最小侵入”）。
>
> 范围：基于仓库当前代码的静态分析与结构检查（模块依赖、目录职责、典型链路示例）。不包含运行期行为验证与性能压测结论（建议在阶段 0/1 补齐）。

---

## 1. 结论摘要（可直接用于后续重构决策）

### 1.1 总体评价

- **模块化“功能切片”维度成立**：`anime/local/storage/user/player` 基本遵循按业务域拆分；feature 之间几乎不直接互相依赖，主要通过 ARouter 路由/Provider 连接，这是良好的方向。
- **“层次/领域解耦”不足是首要结构性问题**：`common_component` 承载了过多横切职责（UI 基建、网络、数据库、存储抽象、Bilibili 业务、日志、配置、通知等），且通过大量 `api` 依赖把实现细节向下游扩散，导致**模块边界形同虚设**。
- **展示层直连数据层**较普遍：多个 ViewModel 直接访问 `DatabaseManager`、网络 Repository 单例、全局管理器（如 `VideoSourceManager`），使可测性降低、复用成本升高、重构影响面扩大。
- **后台组件承担 UI 决策**：例如投屏接收 Service 直接弹窗/跳转，这种模式在生命周期与多进程场景下风险高，不利于稳定性与可维护性。

### 1.2 优先级最高的改进方向

1. **收敛依赖扩散（最优先）**：将 `common_component` 从“依赖伞”收敛为“真实核心能力集合”，减少 `api`，改为“谁用谁依赖”。
2. **把跨模块契约从实现中剥离**：统一沉淀“跨模块接口/路由契约层”（建议命名 `core_contract`），让模块间依赖更明确、可替换。
3. **统一播放拉起链路**：用显式 `PlayRequest/PlayLauncher` 替代 `VideoSourceManager` 的隐式全局状态，降低多入口重复与隐藏耦合。
4. **投屏/共享文件去 UI 穿透**：Service/Provider 不再反查 Activity/弹对话框，而是通过事件/状态仓库与 UI 协作。
5. **`data_component` 去 UI 化**：模型层不引用 `R.drawable` 等 UI 资源，不返回 UI 行为对象（例如 `toAction()`），由 UI 层做映射。

---

## 2. 当前模块清单与依赖方向（文字版）

### 2.1 Gradle 模块

- 应用壳：`app`
- 功能模块：`anime_component`、`local_component`、`storage_component`、`user_component`、`player_component`
- 基础/数据模块：`common_component`、`data_component`
- vendor 包装（本地 AAR）：`repository:danmaku`、`repository:immersion_bar`、`repository:panel_switch`、`repository:seven_zip`、`repository:thunder`、`repository:video_cache`

### 2.2 依赖方向（现状）

- `app` -> `common_component` + 各 feature（`anime/local/storage/user/player`）
- 各 feature -> `common_component`
- `common_component` -> `data_component` + `repository:*` + 大量三方库（且多数以 `api` 向下游暴露）
- `repository:*` -> 本地 `.aar` 工件包装（vendor 层）

> 说明：从“模块依赖图”看，feature 间隔离较好；问题集中在 `common_component` 的职责与依赖暴露方式，使“模块化”更像“目录拆分”。

---

## 3. 逐模块审计

### 3.1 `app`（壳 / 组合根）

**定位是否合理**

- `IApplication` 继承 `BaseApplication`，在壳层做启动装配，定位合理。
- `MainActivity` 负责三 Tab 的 Fragment 装配与路由，符合“组合根”职责。
- `Media3SessionService` 这类会话/后台协调放在壳层也合理（靠近系统组件入口）。

**主要问题（耦合）**

- 壳层直接依赖 feature 内部实现：例如 `MainActivity` 直接引用 `user_component` 的 `DeveloperMenus`（“壳 -> feature 内部类”），会导致后续拆分/替换 `user_component` 的成本上升。

**建议**

- 将“开发者入口/菜单增强”能力移至 `app` 或独立的 `core_developer`，通过路由/接口与 user 模块交互，而不是壳层直接 import feature 类。

---

### 3.2 `common_component`（当前的“超级核心模块”）

**优势**

- MVVM 基建统一（`BaseActivity/BaseViewModel`），重复劳动少。
- 路由表集中（`RouteTable`），跨模块跳转统一。
- 网络、日志、配置集中，功能实现效率高。

**关键问题（结构性风险源头）**

1. **职责过载（God Module）**  
   同一模块内同时包含：UI 基建、网络、数据库、存储抽象、Bilibili 业务、日志、通知、Receiver、Provider 契约等。  
   后果：任何一个横切能力的演进都会触发大范围联动；多人协作冲突概率增大；边界不清导致“随手引用”蔓延。

2. **依赖伞效应（api 暴露过多）**  
   `common_component` 使用大量 `api(...)` 暴露三方库与 vendor 工件，使下游模块可“隐式”拿到依赖与实现细节。  
   后果：依赖约束失效、替换困难、构建时间与增量编译受影响、升级风险放大。

3. **数据层/基础设施强单例化**  
   `DatabaseManager`、`Retrofit` 等以全局单例形式提供；feature 的 ViewModel 可直接调用。  
   后果：可测试性下降、难以做环境切换/Mock、初始化顺序和多进程行为更难管控。

**建议（目标方向）**

- 将 `common_component` 逐步拆分为多个“可理解且职责单一”的 core 模块（见第 5 节路线图）。
- 收敛 `api`：仅保留“确实出现在公共 API 签名中”的依赖为 `api`，其余改 `implementation`；让 feature 显式声明依赖，恢复边界。

---

### 3.3 `data_component`（共享模型 / Room Entity / DTO）

**优势**

- 数据模型统一，减少重复定义；多模块共享实体更方便。

**主要问题**

1. **模型层混入 UI 语义**  
   典型：枚举直接引用 `R.drawable`，并提供 `toAction()` 这种 UI 行为对象构造。  
   后果：数据模块无法独立复用；UI 变更会反向影响数据模块；测试与复用边界变模糊。

2. **依赖选择不够“纯模型”**  
   `data_component` 对外 `api` 暴露 Moshi/ARouter 等，会形成新的依赖扩散源。

3. **领域对象过胖/多态配置混合**  
   如媒体库实体承载多类型配置字段（FTP/SMB/remote/screencast…）。短期可用，但长期会导致校验分散与字段污染。

**建议**

- 立即：把 UI 映射移到 UI/core 层；`data_component` 只保留纯数据与序列化/数据库必要依赖。
- 中期：为“媒体库配置”建立更清晰的分型结构（基表 + 扩展表/JSON blob + 校验器集中化）。

---

### 3.4 `anime_component`（番剧/搜索/追番）

**优势**

- 功能域清晰，UI + ViewModel 组织较直观；路由注入使用一致。

**主要问题**

- 展示层直连数据库/网络：ViewModel 直接写入搜索历史、直接调网络 Repository。  
  后果：业务流程复用困难、单测难、未来替换数据来源成本高。

**建议**

- 引入本模块的 `domain`（UseCase/Interactor）：ViewModel 只调 UseCase；UseCase 通过接口访问 Repository/Dao（可先用简单 Provider 注入，后续再演进 DI）。

---

### 3.5 `local_component`（播放历史/绑定弹幕字幕/本地入口）

**优势**

- 领域覆盖集中，功能落在同一域，用户视角一致。

**主要问题**

- “拉起播放”流程在 ViewModel 内堆叠：DB 查询 + Storage 构造 + 全局 `VideoSourceManager` 注入。  
  后果：同类逻辑在多个模块重复出现；播放入口越多，隐式状态越多，Bug 越难定位。

**建议**

- 抽取统一的播放拉起能力：`PlayRequest`（数据）+ `PlayLauncher`（执行），由一个“核心播放导航层”统一处理来源解析与启动 player。

---

### 3.6 `storage_component`（媒体库/远程/投屏/下载）

**优势**

- 以“存储域”集中组织 UI、Service、Provider、校验器等，便于定位。

**主要问题**

1. **Service 与 UI 强耦合**  
   投屏接收 Service 直接弹 `AlertDialog` 并 `ARouter.navigation()` 拉起播放器。  
   风险：后台/无前台 Activity 时行为不可控；生命周期与多进程复杂；难复用与测试。

2. **Provider 反向穿透 UI 栈**  
   通过 `ActivityHelper` 找到某 Activity 实例取数据。  
   风险：生命周期不可靠、并发场景易空指针、状态来源不透明。

**建议**

- 投屏接收：改为“事件驱动”  
  - Service 只负责协议/接收与落地数据（例如写入状态仓库/DB 或发事件）；
  - UI 层负责确认弹窗与跳转播放；
  - 两者通过 `core_contract` 定义的接口/事件协议协作（统一选型：Flow/Room/广播之一）。
- 共享文件：改为“共享状态仓库”  
  - Provider 只读写 store（StateFlow/Repository），不再反查 Activity。

---

### 3.7 `user_component`（登录/设置/关于/主题等）

**优势**

- 用户相关功能集中，边界明确。

**主要问题**

- “全局开发者入口”类能力放在 user 模块却被壳层直接依赖，导致职责倒置。

**建议**

- 将“开发者入口”独立化（`app` 或 `core_developer`），user 只提供“设置页面/认证能力”等可复用页面或契约。

---

### 3.8 `player_component`（播放内核/Media3/mpv/字幕/弹幕）

**优势**

- 复杂度高但集中，领域隔离相对合理。
- 已存在对外能力 Provider 思路（如 Media3 capability），是向“契约驱动”演进的正向信号。

**主要问题**

1. **包名与模块名不一致**  
   大量代码仍在 `com.xyoye.player`、`com.xyoye.cache` 等包下，降低“模块归属感”，未来拆分子模块或抽 SDK 成本更高。

2. **对 `common_component` 依赖较深**  
   配置、Toast、Bilibili 弹幕、日志等直接使用实现类，player 难以独立演进。

**建议**

- 建立 `player_contract`（或并入 `core_contract`）定义 player 对外依赖接口：日志、配置、错误上报、弹幕/字幕数据源等。  
  player 内部只依赖接口与模型，默认实现放 core 层。

---

### 3.9 `repository:*`（本地 AAR vendor 包装）

**现状**

- 这些模块是本地 `.aar` 的 Gradle 包装，属于 vendor 层。

**主要问题**

- vendor 依赖经由 `common_component api` 传播到所有下游，放大升级风险与依赖污染。

**建议**

- vendor 依赖改为“谁用谁依赖”，避免通过 `common_component` 继续扩散。

---

## 4. 全局高耦合点与风险清单（按优先级）

1. **`common_component` = God Module + 依赖伞**：边界失效、升级风险放大、重构成本集中爆炸。
2. **`data_component` UI 化**：模型层引用 UI 资源/构造 UI 行为，导致数据模块不可独立。
3. **全局单例/隐式状态**：`DatabaseManager`、`Retrofit`、`VideoSourceManager`、`ActivityHelper` 等使链路不透明、测试困难。
4. **后台组件承担 UI 决策**：Service 弹窗/跳转等，生命周期风险高。
5. **壳层依赖 feature 内部类**：职责倒置、替换困难。

---

## 5. 可执行重构路线图（每阶段可独立验收/回滚）

> 原则：优先做“结构性收益大、风险相对可控”的调整；每一步都要能持续编译与验证关键链路，避免一次性“大爆炸改包/改模块”。

### 阶段 0：目标与护栏（1～3 天）

- 输出并评审“模块职责与依赖约束”说明（本文件即为基础，可补充图示与规则）。
- 建立最小回归集（建议至少覆盖）：
  - 任一入口拉起播放（本地/历史/投屏其一）
  - 媒体库列表打开/进入文件
  - 登录/刷新 token（如启用）
  - 投屏接收服务启动/停止与一次播放链路

验收标准：
- 不改变业务行为；补齐/稳定关键链路的自动化验证（unit/instrumented 至少一种）。

---

### 阶段 1：依赖收敛与契约抽离（1～2 周）

目标：
- 让依赖边界重新“可见”，避免继续靠传递依赖存活。

任务清单：
- 收敛 `common_component` 的 `api`：非公共 API 必需依赖改为 `implementation`；各 feature 补齐显式依赖。
- 抽离跨模块契约：把 Provider 接口、跨模块数据协议、路由常量等迁移到 `core_contract`（命名可调整）。
- 解除壳层对 feature 内部类的直接依赖：例如开发者入口能力迁移到 `app` 或 `core_developer`。

验收标准：
- 模块仍可编译；关键回归集通过；依赖图中“隐式传递依赖”明显减少。

---

### 阶段 2：拆分 `common_component`（2～4 周，按能力逐步搬迁）

建议拆分（可按团队习惯合并/调整）：
- `core_ui`：BaseActivity/BaseViewModel、通用控件、adapter、dialog、主题等 UI 基建
- `core_network`：Retrofit/OkHttp、request/拦截器、网络 repository（可按领域再分包）
- `core_database`：Room DB/Dao/migration
- `core_storage`：Storage 抽象、Factory、source 管理
- `core_logging`：日志、上报、采样策略
- `core_contract`：跨模块接口/路由契约/协议模型（尽量无 Android UI 资源依赖）

迁移策略：
- 每拆一个 core，就在旧位置保留“薄转发/兼容入口”（短期），避免一次性全仓库改动。

验收标准：
- 每次迁移一个子域后都能通过关键回归集；`common_component` 体积与对外暴露逐步下降。

---

### 阶段 3：降低运行时耦合（2～4 周）

目标：
- 消除隐式全局状态与 UI 穿透，提高稳定性与可测性。

任务清单：
- 引入 `PlayRequest/PlayLauncher`：
  - 入口模块只构造请求；
  - 统一解析 storage/source 并启动 player；
  - 逐入口迁移（保留旧 `VideoSourceManager` 兼容一段时间）。
- 投屏接收改为事件驱动：
  - Service 只负责接收与落地；
  - UI 负责确认与跳转；
  - 统一通信机制（Flow/Room/广播之一）。
- 共享文件从“反查 Activity”改为“共享状态仓库”。

验收标准：
- 投屏/共享文件链路在无前台 Activity 或 Activity 重建场景下更稳定；
- 播放入口逻辑重复显著减少。

---

### 阶段 4：模型与领域整洁化（可选，长期收益大）

- `data_component` 去 UI 化：移除 UI 资源引用与 UI 行为构造；建立 UI 映射层。
- 媒体库配置演进为分型结构：集中校验器、减少胖字段与 null 判断散落。
- player 领域契约化：日志/配置/上报/弹幕数据源等改接口注入，降低对 core 实现依赖。

---

## 6. 建议的工程治理指标（用于衡量重构收益）

- 模块依赖质量：传递依赖数量、`api` 数量、下游可见依赖收敛程度
- 构建性能：clean build 时间、增量编译时间、单模块构建时间
- 代码健康：核心模块体积（文件数/包数）、跨模块引用数量、循环依赖是否为 0
- 稳定性：关键链路自动化覆盖率、投屏/播放入口崩溃率（如有统计）

---

## 7. 附录：典型问题模式速查

- **God Module / 依赖伞**：一个模块同时承担多领域且对外 `api` 暴露大量依赖。
- **展示层直连数据层**：ViewModel 直接访问 Dao/网络/全局单例。
- **隐式全局状态**：通过单例共享播放源/参数，调用链不透明。
- **后台组件做 UI 决策**：Service 内弹窗/跳转，生命周期不可靠。
- **UI 穿透/反查 Activity**：Provider/工具类通过活动栈拿数据，易产生生命周期 bug。

