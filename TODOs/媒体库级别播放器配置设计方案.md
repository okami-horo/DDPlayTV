# 媒体库级别播放器配置设计方案（DanDanPlayForAndroid）

> 目标：在“全局播放器设置”的基础上，支持**按媒体库（`MediaLibraryEntity`）覆盖播放器内核选择**，并保证“播放 URL 生成 / 播放器启动 / 本地代理策略”等关键链路的一致性，避免隐式依赖导致的错配与难维护问题。

---

## 1. 背景：为什么需要“媒体库级别”的播放器配置

当前项目的播放器内核选择（Media3 / VLC / MPV）是一个**全局配置**：

- `PlayerConfig.usePlayerType`（MMKV）存储全局选择
- `PlayerActivity.initPlayerConfig()` 读取后写入 `PlayerInitializer.playerType`
- `DanDanVideoPlayer` 根据 `PlayerInitializer.playerType` 选择 `PlayerFactory` 创建具体内核

但是，“选择什么播放器”不仅影响 UI/内核能力，还会影响某些媒体库的**可播放 URL 生成方式**：

- `RemoteStorage/WebDavStorage/AlistStorage` 会根据当前 `playerType` 决定是否走 `LocalProxy.wrapIfNeeded(...)`（Range/Seek/风控/签名刷新等）

因此，如果我们只在播放端（`PlayerActivity/DanDanVideoPlayer`）做“媒体库级别播放器选择”，而 `Storage.createPlayUrl()` 仍从全局 `PlayerConfig` 读取 playerType，会产生典型的“**URL 生成使用 A 内核策略，但播放器启动使用 B 内核**”的错配问题，表现为：

- 某些网络源 seek 失败、Range 不兼容、频繁 403/风控、播放时效过期
- 同一媒体库在不同入口（文件列表/播放历史/外部 Intent）行为不一致
- 逻辑分散、隐式依赖增多，后续扩展（如按库配置代理策略）代价陡增

本方案核心就是：让“本次播放的播放器内核与相关策略”成为**单一事实来源（Single Source of Truth）**，并在“生成播放 URL”和“启动播放器”两端统一使用。

---

## 2. 目标与非目标

### 2.1 目标

1. 支持在媒体库维度配置播放器内核：**跟随全局 / 强制 Media3 / 强制 VLC / 强制 MPV**
2. 生成播放 URL 与播放器启动使用同一套“本次播放配置”，避免错配
3. 兼容现有数据：旧用户升级后默认行为不变（仍跟随全局）
4. 结构上可演进：未来扩展到“媒体库级别本地代理/Range 间隔”等不会推倒重来

### 2.2 非目标（本期不做）

- 按“单个视频”配置播放器（视频级别优先级更高，复杂度明显更大）
- 自动探测“某视频应该用哪个内核”（可作为后续策略层扩展）
- 大规模重构模块边界（例如把全部 source/storage 抽到 `core_contract_component`）——本方案只要求接口与依赖方向合理，不强制一次性搬家

---

## 3. 现有架构梳理（关键链路）

### 3.1 媒体库与来源抽象

- `MediaLibraryEntity`：媒体库实体（协议/站点/账号/端口等）（`data_component/.../MediaLibraryEntity.kt`）
- `StorageFactory`：按 `mediaType` 构造对应 `Storage`（`core_storage_component/.../StorageFactory.kt`）
- `Storage`：统一的“媒体库能力”接口，包含 `createPlayUrl/getNetworkHeaders/historyFile` 等（`core_contract_component/.../Storage.kt`）

### 3.2 播放源封装与播放入口

- `StorageVideoSourceFactory.create(file)`：把 `StorageFile` + `playUrl` + 弹幕/字幕/音轨等拼成 `StorageVideoSource`
- `VideoSourceManager`：把 `BaseVideoSource`（当前基本都是 `StorageVideoSource`）从各入口传递到 `PlayerActivity`

### 3.3 播放器选择与隐式耦合点

- 播放器启动：`PlayerActivity.initPlayerConfig()` 从 `PlayerConfig` 读取全局 `usePlayerType` → `PlayerInitializer.playerType`
- 播放 URL 生成：`RemoteStorage/WebDavStorage/AlistStorage.createPlayUrl()` **在 Storage 层**又从 `PlayerConfig` 读取 `usePlayerType` 决定代理策略

> 结论：当前 playerType 同时被“播放端”与“存储端”各读一次，且读的是全局配置，天然不支持按媒体库覆盖。

---

## 4. 总体方案：引入“播放配置档案（Playback Profile）”并在两端统一使用

### 4.1 新增“媒体库级别覆盖字段”（数据层）

在 `media_library` 表新增列（建议 Int）：

- `player_type_override`：播放器内核覆盖值
  - `0`：跟随全局（默认）
  - `2/3/4`：对应 `PlayerType.value`（Media3/VLC/MPV）

为什么放在 Room 表里（而不是像 Bilibili 偏好那样放 MMKV）：

- 这是媒体库的“强关联属性”，应随媒体库导入/编辑/删除一起管理
- UI 上通常在“媒体库编辑”里设置；放 DB 更直观、更一致
- 未来如果做“媒体库导出/同步”，DB 字段更自然

**Room 迁移**：

- `DatabaseInfo` 版本号 +1
- `DatabaseManager` 添加 `MIGRATION_14_15`（示例 SQL）：
  - `ALTER TABLE media_library ADD COLUMN player_type_override INTEGER NOT NULL DEFAULT 0`

### 4.2 定义播放配置档案（PlaybackProfile）（契约层）

新增一个纯数据结构，表示“本次播放应该如何启动播放器、如何生成可播 URL 所需的关键信息”。

建议最小版本先只包含：

- `playerType: PlayerType`
- `source: ProfileSource`（用于日志与排查：GLOBAL / LIBRARY_OVERRIDE / FALLBACK）

预留扩展字段（后续可加，但本期可不落地）：

- `localProxyMode` / `rangeMinIntervalMs`（目前仍沿用全局 `PlayerConfig`）
- `capabilities`（例如某些媒体类型强制 Media3）

放置位置建议：

- 若强调依赖方向：放 `core_contract_component` 或 `data_component`（避免 player 依赖 storage 实现）
- 避免放在 `player_component`，否则 Storage 层很难引用

### 4.3 引入 Resolver：统一“有效 playerType”的计算逻辑（但不硬编码库规则）

新增 `PlaybackProfileResolver`（建议放 `core_system_component` 或 `core_storage_component` 的 util 位置），输入：

- `library: MediaLibraryEntity?`（可空：外部 Intent/临时链接等）
- `globalPlayerType: PlayerType`（来自 `PlayerConfig.usePlayerType`）
- `mediaType: MediaType`（用于兼容性裁剪）

输出：`PlaybackProfile`。

**优先级建议**：

1. 媒体库配置覆盖（`player_type_override != 0`）
2. 全局配置（`PlayerConfig.usePlayerType`）
3. 媒体库“支持的播放器集合”裁剪与回退（由媒体库源码/Storage 实现声明）

> 设计决策：对“明显不兼容的组合”，不在通用层按 `MediaType` 写死规则；而是由对应媒体库的源码（通常对应某个 `Storage` 实现/模块）声明“支持哪些 PlayerType”。  
> 例如：`BilibiliStorage` 对 Media3 管线最适配，则 **supportedPlayerTypes = { Media3 }**，从 UI 到运行时都只允许 Media3。

兼容性回退原则：
- **不改变用户配置存储**（不回写全局/媒体库设置）
- 仅对本次播放生效，并输出可观测信息（日志 + 必要时 Toast）

### 4.4 关键改造：让 `Storage.createPlayUrl` 显式接收 profile（去隐式依赖）

这是保证一致性的关键点。

现状：`Storage.createPlayUrl(file)` 内部读取全局 `PlayerConfig`，属于“隐藏依赖”。

建议演进方式（兼容式变更，避免一次性全部重写）：

1. 在 `Storage` 接口新增新方法（默认实现回退到旧方法）：
   - `suspend fun createPlayUrl(file: StorageFile, profile: PlaybackProfile): String? = createPlayUrl(file)`
2. `StorageVideoSourceFactory` 统一调用新方法（永远传 profile）
3. 对“依赖 playerType 决策 URL/代理”的 Storage 实现**必须**重写新方法：
   - `RemoteStorage`
   - `WebDavStorage`
   - `AlistStorage`

这样做的好处：

- 从架构上消除 Storage 对全局 `PlayerConfig.usePlayerType` 的隐式耦合
- 为“媒体库级别代理策略”留出扩展点：以后 profile 增字段即可，不需要再改接口

### 4.5 播放入口统一：在“创建 VideoSource 时”就确定 profile

因为 `StorageVideoSourceFactory.create()` 会在播放页打开前就生成 `playUrl`，所以 profile 必须在**入口阶段**就被计算出来。

建议统一流程（伪流程）：

1. 入口拿到 `MediaLibraryEntity`（或至少拿到 `storageId/mediaType`）
2. 从 `PlayerConfig` 读取全局 `usePlayerType`
3. 调用 `PlaybackProfileResolver.resolve(...)` 得到 profile
4. 调用 `StorageVideoSourceFactory.create(file, profile)` 生成 `StorageVideoSource`
5. 通过 `VideoSourceManager` 把 source（以及必要时的 profile/launchParams）传入 `PlayerActivity`
6. `PlayerActivity` 使用**同一个 profile**设置 `PlayerInitializer.playerType`（不再直接读全局作为“本次播放内核”）

> 建议让 source 持有 profile（例如 `StorageVideoSource.playbackProfile`），这样 PlayerActivity 无需再猜测/重复 resolve，也能更容易保证一致性与日志追踪。

### 4.6 UI/交互：媒体库编辑页增加“播放器内核”选项

落点建议：各 `*StorageEditDialog`（或其公共基类）增加同一段 UI：

- 标题：播放器内核
- 选项：
  - 跟随全局（默认）
  - Media3（推荐）
  - VLC
  - MPV
- 保存：写入 `MediaLibraryEntity.player_type_override`
- 不在媒体库列表页提供“快速切换本库内核”的入口：统一通过媒体库编辑界面修改，避免额外交互与状态心智负担

对于“内置媒体库”（本地/串流/磁链/播放历史）：

- 如果它们也显示在媒体库列表且可编辑，则同样允许配置覆盖（这在实际使用上非常有价值）
- 如果某些内置库不允许编辑，则在 UI 层隐藏该项即可，但 Resolver/数据层保持一致

---

## 5. 兼容性与能力约束：由媒体库声明支持的 PlayerType

不同内核对不同源的能力可能不同（DASH/MPD、Header 注入、Range/Seek、DRM、外挂字幕管线等）。本方案采用**库自治**：每个媒体库（`Storage` 实现）声明其“支持的播放器内核集合”，通用层只做裁剪与一致性保证。

### 5.1 推荐接口形态

在 `Storage`（或拆出一个 `StoragePlayerPolicy`）新增能力：

- `fun supportedPlayerTypes(): Set<PlayerType>`
- （可选）`fun preferredPlayerType(): PlayerType`：用于当“全局/覆盖”不被支持时的回退目标

约束：

- UI 层展示的可选项必须来源于 `supportedPlayerTypes()`  
- Resolver 必须对“用户选择”做裁剪：`effective = requested.takeIf { it in supported } ?: preferred`

### 5.2 示例：Bilibili 强制 Media3

对 `BilibiliStorage`：

- `supportedPlayerTypes() = setOf(PlayerType.TYPE_EXO_PLAYER)`
- UI 中不展示“跟随全局/VLC/MPV”，而是显示“播放器内核：Media3（固定）”
- 运行时即使全局是 VLC/MPV，也会被裁剪为 Media3（本次播放），并记录日志用于排查

---

## 6. 具体改动清单（按模块）

### 6.1 data_component / core_database_component

- `MediaLibraryEntity`：新增字段 `playerTypeOverride: Int = 0`
- `DatabaseInfo`：版本号 +1
- `DatabaseManager`：新增迁移 `MIGRATION_14_15`

### 6.2 core_contract_component / core_storage_component

- `Storage` 接口：新增 `createPlayUrl(file, profile)` 默认实现
- `Storage`（或 `StoragePlayerPolicy`）：新增 `supportedPlayerTypes()/preferredPlayerType()`，由各媒体库实现声明
- `StorageVideoSourceFactory`：新增重载 `create(file, profile)` 并统一使用新接口
- `RemoteStorage/WebDavStorage/AlistStorage`：改为使用 `profile.playerType` 决定代理策略（不再读取全局 `PlayerConfig.usePlayerType`）

### 6.3 player_component

- `PlayerActivity.initPlayerConfig()`：本次播放的 `playerType` 改为来自 `PlaybackProfile`（仍保留其它全局项：SurfaceView/倍速/弹幕/字幕配置等）
- 增加日志：输出 `playerType` 的来源（GLOBAL / LIBRARY_OVERRIDE / FALLBACK）

### 6.4 storage_component / local_component / anime_component 等入口

所有创建 `StorageVideoSource` 的入口统一改造为“先 resolve profile 再 create source”，典型包括：

- `StorageFileViewModel.setupVideoSource(...)`
- `PlayHistoryViewModel.setupHistorySource(...)` / `openStreamLink(...)`
- `PlayerIntentViewModel.setupLinkSource(...)`
- `AnimeEpisodeFragmentViewModel` 等

---

## 7. 测试策略（建议）

1. **单元测试**：`PlaybackProfileResolverTest`
   - 覆盖：无库/跟随全局/库覆盖/非法值回退/能力约束回退
2. **回归验证（手工）**：
   - WebDav/Remote/Alist：分别设置为 VLC/MPV，确认 seek/快进/重复打开稳定（验证代理策略生效）
   - 播放历史入口：确认能继承原库的覆盖配置
   - 外部链接入口：明确策略（跟随全局或使用 STREAM 库配置），并与设计一致

---

## 8. 迭代计划（建议按两期落地）

### 第 1 期：打通“媒体库覆盖 playerType”闭环

- 数据库字段 + UI 配置
- 引入 `PlaybackProfileResolver`
- Storage 层显式接收 profile（至少覆盖 Remote/WebDav/Alist）
- PlayerActivity 使用 profile 启动内核

验收标准：

- 任意媒体库可配置“覆盖内核”，播放时 URL 与播放器内核一致
- Remote/WebDav/Alist 的代理策略随库配置变化（不再跟全局）

### 第 2 期：能力约束与体验优化

- 为特定 `mediaType` 增加兼容性裁剪（必要时回退 Media3）
- 增强日志/提示与问题定位能力
- 可选：扩展到“媒体库级别代理策略/Range 间隔”等

---

## 9. 风险与应对

- **接口改动范围大**：通过“新增重载 + 默认实现”方式渐进迁移；优先改动依赖 playerType 的 Storage
- **入口分散导致漏改**：以 `StorageVideoSourceFactory.create(...)` 为统一入口强制传 profile，并在编译期暴露缺口
- **内置媒体库使用 `copy(url=...)` 绕开 DB**：明确策略（跟随全局或查询 DB 的内置库配置），并在入口统一处理，避免“同名媒体库配置不生效”
- **库支持集合与 UI/运行时不一致**：把“可选项来源”收敛到 `supportedPlayerTypes()`，并在 Resolver 中做最终裁剪，杜绝仅 UI 限制导致的旁路入口错配（播放历史/外部 Intent）

---

## 10. 决策记录

1. 外部 Intent / 临时链接播放：**不绑定任何媒体库配置**，始终使用全局播放器配置（`PlayerConfig.usePlayerType`）。
   - 外部 Intent：Android 通过 `Intent.ACTION_VIEW` 启动 App 打开一个 `Uri`（例如从浏览器/文件管理器“用弹弹播放打开”）。入口参考：`player_component/.../PlayerIntentActivity.kt` → `PlayerIntentViewModel.openIntentUrl(...)`。
   - 临时链接：App 内直接输入/粘贴 URL 后播放，不通过某个已配置媒体库的目录浏览获得 `StorageFile`，通常用 `LinkStorage` 把 URL 包装成单文件播放源。入口参考：`local_component/.../PlayHistoryViewModel.openStreamLink(...)`（以及 `core_storage_component/.../LinkStorage.kt`）。
